import { describe, it, expect, jest, beforeEach, afterEach } from '@jest/globals';
import { findResolutionRestrictions } from '../src/index.js';

// Mock для navigator.mediaCapabilities
const mockDecodingInfo = jest.fn();

beforeEach(() => {
  // Создаем мок для navigator.mediaCapabilities
  global.navigator = {
    mediaCapabilities: {
      decodingInfo: mockDecodingInfo,
    },
  } as any;
});

afterEach(() => {
  jest.clearAllMocks();
});

describe('findResolutionRestrictions', () => {
  it('should return error when decodingInfo throws', async () => {
    const error = new Error('Test error');
    mockDecodingInfo.mockRejectedValue(error);

    const result = await findResolutionRestrictions({
      type: 'file',
      video: {
        contentType: 'video/mp4; codecs="avc1.42E01E"',
        framerate: 25,
        bitrate: 2000000,
      },
    });

    expect(result.supported.error).toBeDefined();
    expect(result.supported.error?.name).toBe('Error');
    expect(result.supported.value).toBe(false);
  });

  it('should return false when codec is not supported', async () => {
    mockDecodingInfo.mockResolvedValue({
      supported: false,
      smooth: false,
      powerEfficient: false,
    });

    const result = await findResolutionRestrictions({
      type: 'file',
      video: {
        contentType: 'video/mp4; codecs="avc1.42E01E"',
        framerate: 25,
        bitrate: 2000000,
      },
    });

    expect(result.supported.value).toBe(false);
    expect(result.smooth.value).toBe(false);
    expect(result.powerEfficient.value).toBe(false);
  });

  it('should return supported when codec is supported', async () => {
    mockDecodingInfo.mockResolvedValue({
      supported: true,
      smooth: true,
      powerEfficient: true,
    });

    const result = await findResolutionRestrictions({
      type: 'file',
      video: {
        contentType: 'video/mp4; codecs="avc1.42E01E"',
        framerate: 25,
        bitrate: 2000000,
      },
    });

    expect(result.supported.value).toBe(true);
    expect(result.smooth.value).toBe(true);
  });
});

